1) Extend the State (for dynamic planning)

Add these fields to State + DEFAULT_STATE:

uuidPlan: List[Dict[str,str]] — per-record map slotSlug -> @id

slotTypeMap: Dict[str,str] — @id -> @type (full IRI)

recordFingerprints: List[str] — stable SHA-256 per record

plannerVersion: str — e.g., "v2"

(optional) slotOwnership: Dict[str,Any] — per record, slot → owner/type metadata
Reason: enables incremental updates, stable IDs, and proper typing in generation. 

state

2) Implement a dynamic planner (uuid5 + incremental)

Replace your planner with a node that:

Normalizes each record → canonical JSON string → sha256 fingerprint.

Uses uuid5 for determinism:

record_uuid = uuid5(NS_RECORD, fingerprint)

slot_uuid = uuid5(NS_SLOT, f"{record_uuid}:{slotSlug}")

Builds slot slugs from ontology (see §3), not string guesses.

Incremental behavior:

New fingerprints → append new plan rows.

Changed fingerprints → re-plan only those rows.

Missing fingerprints → remove (or soft-delete) those rows.

Router safety: if no records, return uuidPlan: [] (not None) to avoid routing loops. 

graph

Persist uuidPlan, slotTypeMap, recordFingerprints, plannerVersion. Session storage via SqliteSaver already persists this across steps. 

services

3) Derive slots from ontology/custom facets (artifact-agnostic)

From ontologyMap + customFacets:

Create fullTypeBySlug:

slug = lowercase(last segment), e.g., uco-observable:FileFacet → filefacet

map all classes & facets (not just files). 

config

custom_facet

For each record, compute slot set:

Include all required class slots (e.g., file, windowsregistrykey, process, etc.)

Include facet slots only when the record has at least one property owned by that facet (use ontologyMap.properties ownership).
This keeps it domain-agnostic and correct for any CASE/UCO object. 

config

4) Plan relationship nodes (when present)

If ontologyMap defines relationships for the record, add a slot per relationship:

Slug pattern: relationship_<kind>_<srcSlug>_<tgtSlug>

Type: uco-observable:ObservableRelationship

ID: uuid5(NS_SLOT, f"{record_uuid}:{slug}")
Your graph-generator already supports relationships (Example C). 

config

5) Produce slotTypeMap for the generator

For every planned @id, set slotTypeMap[@id] = fullIRIType. The generator then types the skeleton deterministically and stays domain-agnostic (files, processes, registry, network, email, etc.). 

config

6) Integrate with router (no loops, partial invalidation)

Treat uuidPlan: [] as “planned” (so the router proceeds). 

graph

Keep invalidate_uuid_plan_node, but allow partial invalidation:

Accept a list of @ids, fingerprints, or slot slugs to drop/replan instead of nuking the whole plan.
Router already supports regenerating UUIDs on ID-related validation errors; this targets only what’s broken. 

graph

7) Generator alignment (no code churn, just consume maps)

In graph_generator_node, read uuidPlan to create one node per planned slot and set @type via slotTypeMap.

Keep enforcing property placement on facets vs. objects as your prompt specifies; the validator will catch violations. 

config

validator

8) Validation & hallucination loops stay unchanged

Structural validation runs after generation; on ID/ref issues, route to partial invalidation; on other issues, route back to supervisor/generator. 

graph

Hallucination check & fallback stay as-is. 

graph

9) Edge-case handling

Zero records / raw text → return uuidPlan: [], slotTypeMap: {}. 

graph

Duplicates → either dedup or salt by occurrence index in the planner (configurable).

Ontology change mid-session → recompute slot sets per affected record; add/remove only changed slots; record UUIDs remain stable (fingerprints).

Custom facets → treated like any facet; include when their owned props appear in the record. 

custom_facet

10) Acceptance tests (must pass)

Determinism: same input twice → identical uuidPlan & slotTypeMap.

Incremental add: append a record → only one new row added.

Update: change one record → only that row and its slots get new IDs.

Delete: remove a record → its row disappears; generator/validator still pass.

Ontology change: add a facet → only affected rows gain new facet slots/IDs.

Zero records: router doesn’t loop; run completes with empty graph. 

graph

Relationships: when declared, planner emits relationship slots; generator emits edges (Example C). 

config

File-by-file changes

state.py: add the new planner fields to State + DEFAULT_STATE. 

state

uuid_planner.py: implement dynamic planner (uuid5 + fingerprints + slot derivation + partial invalidation). 

uuid_planner

graph.py:

Accept uuidPlan: [] as “planned”.

Keep current routing but wire partial invalidation path. 

graph

graph_generator_node:

Consume slotTypeMap to set @type for each @id and build the skeleton; keep your strict placement rules. 

config